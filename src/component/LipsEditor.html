<div>
    <style>
        #morphTargetsList > * {
            text-align: center; /* Center the content inside the list item */
        }

        /* Apply styles to range inputs */
        #morphTargetsList input[type="range"] {
            width: 100%; /* Set the width to 100% to fill the entire column */
        }

        /* Apply styles to target names (labels) */
        #morphTargetsList label {
            display: block; /* Make the label a block element to move it to a new line */
            margin-top: 5px; /* Add margin at the top for spacing */
        }

        #morphTargetsList img {
            width: 100%;
        }
    </style>
    <b>Lips Editor</b>
    <div id="lips_row_sample" class="col-3 d-none">
        <div class="card shadow my-1">
            <button>
                <img src="" width="100%"/>
                <label class="lip_name"></label>
                <label class="lip_target d-none"></label>
            </button>
        </div>
    </div>

    <div id="lips_button" class="row">
    </div>

    <label>Expressiveness :</label>
    <div class="row">
        <div class="col-8">
            <input id="Expressiveness_range"
                   type="range" min="0" max="100" value="50"
                   style="width: 100%">
        </div>
        <div class="col-4">
            <input id="Expressiveness_number" class="form-control" value="50" type="number">
        </div>
    </div>


    <input id="lipsync_audio_file" type="file">
    <audio id="lipsync_audio" controls></audio>
    <button class="btn btn-primary form-control my-3" id="runButton">
        Auto LipSync
        <div id="lipsync_loading" class="spinner-border spinner-border-sm text-light" style="display: none"
             role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </button>


    <script src="./js/AutoLipSyncer.js"></script>

    <script>


        function updateActiveButtonByName(name) {
            // Remove active_outline class from all buttons
            var allButtons = document.querySelectorAll("#lips_button button");
            allButtons.forEach(function (btn) {
                btn.classList.remove("active_outline");
                if (btn.querySelector(".lip_target").textContent === name) {
                    btn.classList.add("active_outline");
                }
            });
        }

        // Function to create and append lips elements
        function createLipsElement(name, target, url) {
            var lipsRowSample = document.getElementById("lips_row_sample").cloneNode(true);
            lipsRowSample.classList.remove("d-none");
            lipsRowSample.querySelector("img").setAttribute("src", url);
            lipsRowSample.querySelector(".lip_name").textContent = name; // Set lip name
            lipsRowSample.querySelector(".lip_target").textContent = target; // Set lip name
            lipsRowSample.querySelector("button").addEventListener("click", function () {
                // Handle click event for the lips element if needed
                updateActiveButtonByName(target);

                addVisemeKeyframeTimelineView(target);

                addVisemeKeyframe(target);
            });

            return lipsRowSample;
        }


        function addVisemeKeyframe(viseme_name) {

            var title = "Head";
            var FaceAnimationGroup = scene.getAnimationGroupByName(HeadMesh.name + "_talk_" + title);

            if (FaceAnimationGroup == null) {
                FaceAnimationGroup = new BABYLON.AnimationGroup(HeadMesh.name + "_talk_" + title);
            }



            var Expressiveness_range = parseInt(document.getElementById("Expressiveness_range").value) / 100;


            var morphVisemeKeys = [];

            var viseme = findMorph(HeadMesh.morphTargetManager, viseme_name);
            if (viseme) {
                var start = millisecondsToFrames(timeline.getTime());
                var end = start + 12;
                var mid = start + Math.round((end - start) / 2);

                var morphTargetKeys = [];
                morphTargetKeys.push({
                    frame: start,
                    value: 0.0
                });
                morphTargetKeys.push({
                    frame: mid,
                    value:Expressiveness_range
                });
                morphTargetKeys.push({
                    frame: end,
                    value: 0.0
                });

                if (!morphVisemeKeys[viseme_name]) {
                    morphVisemeKeys[viseme_name] = [];
                }
                morphVisemeKeys[viseme_name].push(morphTargetKeys);
            }


            combineKeyFrames(FaceAnimationGroup, morphVisemeKeys, 3, HeadMesh);

            updateObjectNamesFromScene();

        }

        function addVisemeKeyframeTimelineView(name) {
            if (timeline) {
                const currentModel = timeline.getModel();
                // Find the 'Viseme' row in the current model
                const visemeRow = currentModel.rows.find(row => row.title === 'Viseme');
                var Expressiveness_range = parseInt(document.getElementById("Expressiveness_range").value) / 100;

                // If 'Viseme' row exists, check if a keyframe with the same 'val' property already exists
                if (visemeRow) {
                    const existingKeyframeIndex = visemeRow.keyframes.findIndex(keyframe => keyframe.val === timeline.getTime());

                    // If a keyframe with the same 'val' property exists, remove it
                    if (existingKeyframeIndex !== -1) {
                        visemeRow.keyframes.splice(existingKeyframeIndex, 1);
                    }

                    // Add the new keyframe to 'Viseme' row
                    visemeRow.keyframes.push({
                        val: timeline.getTime(),
                        shape: 'rhomb',
                        type: 'Viseme',
                        value: name,
                        expression: Expressiveness_range,
                    });
                } else {
                    // If 'Viseme' row doesn't exist, create a new one and add the keyframe
                    currentModel.rows.push({
                        title: 'Viseme',
                        keyframes: [
                            {
                                val: timeline.getTime(),
                                shape: 'rhomb',
                                type: 'Viseme',
                                value: name,
                                expression: Expressiveness_range,
                            }
                        ]
                    });
                }
                timeline.setModel(currentModel);


                HeadMesh.morphTargetManager._targets.forEach(target => {
                    if (target.name === name) {
                        target.influence = Expressiveness_range;
                    } else {
                        target.influence = 0;
                    }
                });

                if (TeethMesh) {
                    TeethMesh.morphTargetManager._targets.forEach(target => {
                        if (target.name === name) {
                            target.influence = Expressiveness_range;
                        } else {
                            target.influence = 0;
                        }
                    });
                }


                // Generate outline list menu
                generateHTMLOutlineListNodes(currentModel.rows);
            }
        }

        // Append lips elements to the lips_button div
        var lipsButtonDiv = document.getElementById("lips_button");
        lips.forEach(function (lip) {
            var lipsElement = createLipsElement(lip.name, lip.target, lip.url);
            lipsButtonDiv.appendChild(lipsElement);
        });

        var rangeInput = document.getElementById("Expressiveness_range");
        var numberInput = document.getElementById("Expressiveness_number");

        // Update number input when range input changes
        rangeInput.addEventListener("input", function () {
            numberInput.value = rangeInput.value;

            var name = getCurrentViseme();
            if (name) {
                addVisemeKeyframeTimelineView(name);
            }
        });

        // Update range input when number input changes
        numberInput.addEventListener("input", function () {
            // Ensure the value is within the range of 0 to 100
            var value = parseInt(numberInput.value);
            if (value < 0) {
                value = 0;
            } else if (value > 100) {
                value = 100;
            }
            rangeInput.value = value;
            numberInput.value = value; // Update number input with sanitized value


            var name = getCurrentViseme();
            if (name) {
                addVisemeKeyframeTimelineView(name);
            }
        });


        function getCurrentViseme() {
            var activeButton = document.querySelector("#lips_button button.active_outline");
            if (activeButton) {
                var lipNameElement = activeButton.querySelector(".lip_target");
                if (lipNameElement) {
                    return lipNameElement.textContent;
                }
            }
            return null; // Return null if no active button with class "active_outline" is found
        }

    </script>
</div>